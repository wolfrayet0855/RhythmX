===== Date+Extension.swift =====
//
//  Date+Extension.swift
//

import Foundation

extension Date {
    func diff(numDays: Int) -> Date {
        Calendar.current.date(byAdding: .day, value: numDays, to: self)!
    }
    
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
}



===== ArchivedDataBlock.swift =====
//
//  ArchivedDataBlock.swift
//

import Foundation

struct ArchivedDataBlock: Codable, Identifiable {
    let id: UUID
    let date: Date
    let groupedEvents: [PhaseEvents]

    /// Custom initializer that allows you to
    /// specify an existing id, or generate a new one.
    init(id: UUID = UUID(), date: Date, groupedEvents: [PhaseEvents]) {
        self.id = id
        self.date = date
        self.groupedEvents = groupedEvents
    }

    struct PhaseEvents: Codable {
        let eventType: Event.EventType
        let events: [Event]
    }
}



===== Event.swift =====
//
//  Event.swift
//  Created by user on 9/27/24.
//

import Foundation

struct Event: Identifiable, Codable {
    enum EventType: String, Identifiable, CaseIterable, Codable {
        case menstrual
        case follicular
        case ovulation
        case luteal

        var id: String { rawValue }

        var icon: String {
            switch self {
            case .menstrual:     return "❶"
            case .follicular:    return "❷"
            case .ovulation:     return "❸"
            case .luteal:        return "❹"
            }
        }
    }

    /// Unique string ID for each event
    var id: String

    var eventType: EventType
    var date: Date

    /// Optional note describing the event
    var note: String

    /// Freeform text for custom tags
    var tags: String

    /// Computed property to convert the event's date to DateComponents
    var dateComponents: DateComponents {
        Calendar.current.dateComponents([.year, .month, .day], from: date)
    }

    // MARK: - Initializer
    init(
        id: String = UUID().uuidString,
        eventType: EventType,
        date: Date,
        note: String,
        tags: String = ""
    ) {
        self.id = id
        self.eventType = eventType
        self.date = date
        self.note = note
        self.tags = tags
    }
}

// MARK: - Sample Events
extension Event {
    static var sampleEvents: [Event] {
        return [
            Event(eventType: .menstrual, date: Date(), note: "Menstrual phase", tags: ""),
            Event(eventType: .follicular, date: Date().addingTimeInterval(86400), note: "Follicular phase", tags: ""),
            Event(eventType: .ovulation, date: Date().addingTimeInterval(172800), note: "Ovulation phase", tags: ""),
            Event(eventType: .luteal, date: Date().addingTimeInterval(259200), note: "Luteal phase", tags: ""),
        ]
    }
}



===== EventStore.swift =====
//
//  EventStore.swift
//

import Foundation
import SwiftUI

@MainActor
class EventStore: ObservableObject {
    @Published var events = [Event]()
    @Published var preview: Bool
    @Published var changedEvent: Event?
    @Published var movedEvent: Event?

    // Key for storing current events in UserDefaults
    private let eventsKey = "com.example.rhythm.events"

    init(preview: Bool = false) {
        self.preview = preview
        fetchEvents()
    }

    /// Load from UserDefaults (or provide empty if in preview)
    func fetchEvents() {
        if preview {
            events = []
        } else {
            loadFromUserDefaults()
        }
    }

    // MARK: - CRUD
    func add(_ newEvent: Event) {
        events.append(newEvent)
        changedEvent = newEvent
        saveToUserDefaults()
    }

    func delete(_ event: Event) {
        if let idx = events.firstIndex(where: { $0.id == event.id }) {
            changedEvent = events.remove(at: idx)
            saveToUserDefaults()
        }
    }

    func update(_ event: Event) {
        if let idx = events.firstIndex(where: { $0.id == event.id }) {
            movedEvent = events[idx]
            events[idx] = event
            changedEvent = event
            saveToUserDefaults()
        }
    }

    // MARK: - Generate cycle events
    func generateCycleEvents(startDate: Date, cycleLength: Int = 28) {
        events.removeAll()
        let phases: [(Event.EventType, Range<Int>)] = [
            (.menstrual,   0..<5),
            (.follicular,  5..<13),
            (.ovulation,   13..<16),
            (.luteal,      16..<cycleLength)
        ]

        for (phaseType, dayRange) in phases {
            for offset in dayRange {
                if let phaseDate = Calendar.current.date(byAdding: .day, value: offset, to: startDate) {
                    let e = Event(
                        eventType: phaseType,
                        date: phaseDate,
                        note: "\(phaseType.rawValue.capitalized) day \(offset+1)"
                    )
                    events.append(e)
                }
            }
        }
        // save after generation
        saveToUserDefaults()
    }

    // Optional: fetch historical events
    func fetchHistoricalEvents(for range: TimeInterval) -> [Event] {
        let startDate = Date().addingTimeInterval(-range)
        return events.filter { $0.date >= startDate }
    }

    // MARK: - Persistence
    private func saveToUserDefaults() {
        do {
            let data = try JSONEncoder().encode(events)
            UserDefaults.standard.set(data, forKey: eventsKey)
        } catch {
            print("Error encoding events: \(error)")
        }
    }

    private func loadFromUserDefaults() {
        guard let data = UserDefaults.standard.data(forKey: eventsKey) else {
            return
        }
        do {
            let decoded = try JSONDecoder().decode([Event].self, from: data)
            self.events = decoded
        } catch {
            print("Error decoding events: \(error)")
        }
    }
}



===== Rhythm.swift =====
//
//  AppEntry.swift
//

import SwiftUI

@main
struct AppEntry: App {
    @StateObject var myEvents = EventStore(preview: true)
    
    // Tracks whether user has completed onboarding
    @AppStorage("didFinishOnboarding") var didFinishOnboarding = false

    // Tracks which tab to show in StartTabView (0 = first tab, 1 = second, 2 = Settings, etc.)
    @AppStorage("selectedTab") var selectedTab = 0

    var body: some Scene {
        WindowGroup {
            if didFinishOnboarding {
                // The user is done with onboarding; show main app
                StartTabView()
                    .environmentObject(myEvents)
            } else {
                // Show Onboarding
                OnboardingView()
                    .environmentObject(myEvents)
            }
        }
    }
}





===== ArchivedDataView.swift =====
//
//  ArchivedDataView.swift
//  Rhythm
//

import SwiftUI

struct ArchivedDataView: View {
    // A binding so we can mutate the parent's array
    @Binding var groupedArchivedData: [ArchivedDataBlock]

    // A callback that clears + saves in the parent
    let clearArchivedData: () -> Void

    // For the confirmation alert
    @State private var showDeleteConfirmation = false

    // For searching tags
    @State private var searchText = ""

    var body: some View {
        NavigationStack {
            List {
                // We iterate over filteredArchivedData
                ForEach(filteredArchivedData) { archiveBlock in
                    Section(header: Text("Archived on \(archiveBlock.date.formatted(date: .abbreviated, time: .omitted))")) {
                        // Sort phases by earliest event date
                        let sortedPhases = archiveBlock.groupedEvents.sorted { phase1, phase2 in
                            let startDate1 = phase1.events.first?.date ?? .distantFuture
                            let startDate2 = phase2.events.first?.date ?? .distantFuture
                            return startDate1 < startDate2
                        }

                        ForEach(sortedPhases, id: \.eventType.id) { phase in
                            if let firstDate = phase.events.first?.date,
                               let lastDate = phase.events.last?.date
                            {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("\(phase.eventType.rawValue.capitalized) Phase")
                                        .font(.headline)
                                    Text(
                                        firstDate.formatted(date: .abbreviated, time: .omitted)
                                        + " – "
                                        + lastDate.formatted(date: .abbreviated, time: .omitted)
                                    )
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)

                                    // Show each event's tags (already filtered by search)
                                    ForEach(phase.events, id: \.id) { archivedEvent in
                                        if !archivedEvent.tags.isEmpty {
                                            Text("• \(archivedEvent.tags)")
                                                .font(.footnote)
                                                .foregroundColor(.blue)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle("Archived Data")
            // Add a search bar
            .searchable(text: $searchText, prompt: "Search tags...")
            // Toolbar button for clearing data
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(role: .destructive) {
                        showDeleteConfirmation = true
                    } label: {
                        Text("Clear Archive")
                    }
                }
            }
            // Confirmation .alert for deletion
            .alert("Delete All Archived Data?", isPresented: $showDeleteConfirmation) {
                Button("Delete", role: .destructive) {
                    clearArchivedData()
                }
                Button("Cancel", role: .cancel) {}
            } message: {
                Text("This action will permanently remove all archived data.")
            }
        }
    }

    /// Filter archived data based on `searchText` in the `tags`
    private var filteredArchivedData: [ArchivedDataBlock] {
        // If user hasn't entered anything, show all
        guard !searchText.isEmpty else {
            return groupedArchivedData
        }

        // Otherwise, filter
        return groupedArchivedData.compactMap { block in
            // Filter the block's phases
            let filteredPhases = block.groupedEvents.compactMap { phase -> ArchivedDataBlock.PhaseEvents? in
                // Among this phase's events, keep only those matching the search text
                let matchingEvents = phase.events.filter {
                    $0.tags.range(of: searchText, options: .caseInsensitive) != nil
                }
                // If no matches, skip this phase
                guard !matchingEvents.isEmpty else {
                    return nil
                }
                // Otherwise build the new filtered PhaseEvents
                return ArchivedDataBlock.PhaseEvents(eventType: phase.eventType, events: matchingEvents)
            }

            // If after filtering, no phases remain, skip this entire block
            guard !filteredPhases.isEmpty else {
                return nil
            }

            // Otherwise, build a new block with only the matching phases
            return ArchivedDataBlock(
                id: block.id,          // preserve original ID
                date: block.date,
                groupedEvents: filteredPhases
            )
        }
    }
}




===== CalendarView.swift =====
//
//  CalendarView.swift
//

import SwiftUI

struct CalendarView: UIViewRepresentable {
    typealias UIViewType = UICalendarView

    let interval: DateInterval
    @ObservedObject var eventStore: EventStore
    @Binding var dateSelected: DateComponents?
    @Binding var displayEvents: Bool

    func makeUIView(context: Context) -> UICalendarView {
        let uiCalendar = UICalendarView()
        uiCalendar.delegate = context.coordinator
        uiCalendar.calendar = Calendar(identifier: .gregorian)
        uiCalendar.availableDateRange = interval

        let dateSelection = UICalendarSelectionSingleDate(delegate: context.coordinator)
        uiCalendar.selectionBehavior = dateSelection
        return uiCalendar
    }

    func updateUIView(_ uiView: UICalendarView, context: Context) {
        if let changedEvent = eventStore.changedEvent {
            uiView.reloadDecorations(forDateComponents: [changedEvent.dateComponents], animated: true)
            DispatchQueue.main.async {
                eventStore.changedEvent = nil
            }
        }

        if let movedEvent = eventStore.movedEvent {
            uiView.reloadDecorations(forDateComponents: [movedEvent.dateComponents], animated: true)
            DispatchQueue.main.async {
                eventStore.movedEvent = nil
            }
        }
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }

    class Coordinator: NSObject, @preconcurrency UICalendarViewDelegate, UICalendarSelectionSingleDateDelegate {
        let parent: CalendarView

        init(parent: CalendarView) {
            self.parent = parent
        }

        @MainActor func calendarView(
            _ calendarView: UICalendarView,
            decorationFor dateComponents: DateComponents
        ) -> UICalendarView.Decoration? {
            let foundEvents = parent.eventStore.events.filter {
                $0.date.startOfDay == dateComponents.date?.startOfDay
            }
            if foundEvents.isEmpty {
                return nil
            }
            if foundEvents.count > 1 {
                return .image(
                    UIImage(systemName: "doc.on.doc.fill"),
                    color: .red,
                    size: .large
                )
            }
            if let singleEvent = foundEvents.first {
                return .customView {
                    let label = UILabel()
                    label.text = singleEvent.eventType.icon
                    return label
                }
            }
            return nil
        }

        func dateSelection(
            _ selection: UICalendarSelectionSingleDate,
            didSelectDate dateComponents: DateComponents?
        ) {
            DispatchQueue.main.async {
                self.parent.dateSelected = dateComponents
                guard let dateComponents else { return }
                let foundEvents = self.parent.eventStore.events.filter {
                    $0.date.startOfDay == dateComponents.date?.startOfDay
                }
                if !foundEvents.isEmpty {
                    self.parent.displayEvents.toggle()
                }
            }
        }

        func dateSelection(
            _ selection: UICalendarSelectionSingleDate,
            canSelectDate dateComponents: DateComponents?
        ) -> Bool {
            true
        }
    }
}



===== DaysEventsListView.swift =====
//
//  DaysEventsListView.swift
//

import SwiftUI

struct DaysEventsListView: View {
    @EnvironmentObject var eventStore: EventStore
    @Binding var dateSelected: DateComponents?
    @State private var formType: EventFormType?

    var body: some View {
        NavigationStack {
            Group {
                if let dateSelected {
                    let foundEvents = eventStore.events.filter {
                        $0.date.startOfDay == dateSelected.date?.startOfDay
                    }
                    List {
                        ForEach(foundEvents) { event in
                            ListViewRow(event: event, formType: $formType)
                                .swipeActions {
                                    Button(role: .destructive) {
                                        eventStore.delete(event)
                                    } label: {
                                        Image(systemName: "trash")
                                    }
                                }
                                .sheet(item: $formType) { $0 }
                        }
                    }
                }
            }
            .navigationTitle(
                dateSelected?.date?.formatted(
                    date: .long,
                    time: .omitted
                ) ?? ""
            )
        }
    }
}

struct DaysEventsListView_Previews: PreviewProvider {
    static var dateComponents: DateComponents {
        var dateComponents = Calendar.current.dateComponents(
            [.month, .day, .year, .hour, .minute],
            from: Date()
        )
        dateComponents.timeZone = TimeZone.current
        dateComponents.calendar = Calendar(identifier: .gregorian)
        return dateComponents
    }

    static var previews: some View {
        DaysEventsListView(dateSelected: .constant(dateComponents))
            .environmentObject(EventStore(preview: true))
    }
}



===== EventsCalendarView.swift =====
//
//  EventsCalendarView.swift
//

import SwiftUI

struct EventsCalendarView: View {
    @EnvironmentObject var eventStore: EventStore
    @State private var dateSelected: DateComponents?
    @State private var displayEvents = false

    var body: some View {
        NavigationStack {
            ScrollView {
                CalendarView(
                    interval: DateInterval(start: .distantPast, end: .distantFuture),
                    eventStore: eventStore,
                    dateSelected: $dateSelected,
                    displayEvents: $displayEvents
                )
                Image("launchScreen")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 100)
            }
            .sheet(isPresented: $displayEvents) {
                DaysEventsListView(dateSelected: $dateSelected)
                    .presentationDetents([.medium, .large])
            }
            .navigationTitle("Calendar View")
        }
    }
}

struct EventsCalendarView_Previews: PreviewProvider {
    static var previews: some View {
        EventsCalendarView()
            .environmentObject(EventStore(preview: true))
    }
}



===== EventFormType.swift =====
//
//  EventFormType.swift
//

import SwiftUI

enum EventFormType: Identifiable, View {
    // case new    <-- REMOVED
    case update(Event)

    var id: String {
        switch self {
        case .update:
            return "update"
        }
    }

    var body: some View {
        switch self {
        case .update(let e):
            EventFormView(viewModel: EventFormViewModel(e))
        }
    }
}



===== EventFormView.swift =====
//
//  EventFormView.swift
//

import SwiftUI

struct EventFormView: View {
    @EnvironmentObject var eventStore: EventStore
    @StateObject var viewModel: EventFormViewModel
    @Environment(\.dismiss) var dismiss
    @FocusState private var focus: Bool?

    var body: some View {
        NavigationStack {
            VStack {
                Form {
                    DatePicker("Date and Time", selection: $viewModel.date)
                    
                    Picker("Phase Type", selection: $viewModel.eventType) {
                        ForEach(Event.EventType.allCases) { et in
                            Text(et.icon + " " + et.rawValue.capitalized)
                                .tag(et)
                        }
                    }

                    TextField("Note", text: $viewModel.note, axis: .vertical)
                        .focused($focus, equals: true)

                    TextField("Custom Tags (freeform)", text: $viewModel.tags)
                        .focused($focus, equals: false)

                    Section(footer:
                        HStack {
                            Spacer()
                            Button {
                                // Only allow "update" scenario
                                if viewModel.updating {
                                    let updated = Event(
                                        id: viewModel.id!,
                                        eventType: viewModel.eventType,
                                        date: viewModel.date,
                                        note: viewModel.note,
                                        tags: viewModel.tags
                                    )
                                    eventStore.update(updated)
                                    dismiss()
                                } else {
                                    // NO-OP (ignore attempts to add brand-new event)
                                }
                            } label: {
                                Text("Update Event")
                            }
                            .buttonStyle(.borderedProminent)
                            .disabled(!viewModel.updating || viewModel.incomplete)
                            Spacer()
                        }
                    ) {
                        EmptyView()
                    }
                }
            }
            .navigationTitle("Edit Event")
            .onAppear {
                focus = true
            }
        }
    }
}

struct EventFormView_Previews: PreviewProvider {
    static var previews: some View {
        // Provide an event so we're "updating"
        let sampleEvent = Event(
            eventType: .menstrual,
            date: Date(),
            note: "Sample edit",
            tags: "example"
        )
        EventFormView(viewModel: EventFormViewModel(sampleEvent))
            .environmentObject(EventStore())
    }
}



===== EventFormViewModel.swift =====
//
//  EventFormViewModel.swift
//

import Foundation

class EventFormViewModel: ObservableObject {
    @Published var date = Date()
    @Published var note = ""
    @Published var eventType: Event.EventType = .menstrual
    @Published var tags = ""
    
    var id: String?
    var updating: Bool { id != nil }
    
    init() {}

    init(_ event: Event) {
        date = event.date
        note = event.note
        eventType = event.eventType
        tags = event.tags
        id = event.id
    }

    var incomplete: Bool {
        note.isEmpty
    }
}



===== GettingStartedView.swift =====
//  GettingStartedView.swift
//

import SwiftUI

struct GettingStartedView: View {
    // After reading the steps, user can tap "Done"
    @AppStorage("didFinishOnboarding") var didFinishOnboarding = false
    @AppStorage("selectedTab") var selectedTab = 0

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                Text("1) Generate Cycle Events")
                    .font(.headline)
                Text("In Settings, tap ‘Generate Events’ to populate your calendar with your chosen cycle length.")

                Text("2) Add Tags")
                    .font(.headline)
                Text("Use the ‘Events List’ tab to add new tags (e.g., Dietary, Mood). Tap the plus (+) button to attach a tag to a date.")

                Text("3) Check Calendar")
                    .font(.headline)
                Text("In the ‘Calendar’ tab, see your phases & events. Tap a date to view/edit tags.")

                Text("4) Archive Data")
                    .font(.headline)
                Text("Each month in Settings, archive your previous data and generate new menstrual phase events. Use the Archive Data view to explore trends in your tags.")

                Text("5) Learn More")
                    .font(.headline)
                Text("In Settings, open ‘Menstrual Phases Info’ for details on each phase.")
            }
            .padding()
        }
        .navigationTitle("Getting Started")
        // We do NOT hide the back button, so user can return to OnboardingView
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Done") {
                    // Mark onboarding finished + jump them to Settings tab
                    selectedTab = 2
                    didFinishOnboarding = true
                }
            }
        }
    }
}

struct GettingStartedView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationStack {
            GettingStartedView()
        }
    }
}



===== EventsListView.swift =====
//
//  EventsListView.swift
//

import SwiftUI

struct EventsListView: View {
    @EnvironmentObject var myEvents: EventStore
    
    // We will show a TagFormView in a sheet
    @State private var showTagForm = false
    
    var body: some View {
        NavigationStack {
            List {
                // Group events by eventType (the phases)
                let grouped = Dictionary(grouping: myEvents.events) { $0.eventType }

                ForEach(Event.EventType.allCases, id: \.self) { phase in
                    if let phaseEvents = grouped[phase], !phaseEvents.isEmpty {
                        Section {
                            // Sort by date
                            let sorted = phaseEvents.sorted { $0.date < $1.date }
                            if let earliest = sorted.first, let latest = sorted.last {
                                // Show single row for the phase date range
                                HStack {
                                    VStack(alignment: .leading, spacing: 6) {
                                        Text("\(phase.icon) \(phase.rawValue.capitalized) Phase")
                                            .font(.headline)
                                        Text(
                                            earliest.date.formatted(date: .abbreviated, time: .omitted)
                                            + " – "
                                            + latest.date.formatted(date: .abbreviated, time: .omitted)
                                        )
                                        .font(.subheadline)
                                        .foregroundColor(.secondary)
                                        
                                        // Combine all tags from events in this phase (optional)
                                        let combinedTags = sorted
                                            .map { $0.tags }
                                            .filter { !$0.isEmpty }
                                            .joined(separator: ", ")
                                        if !combinedTags.isEmpty {
                                            Text("Tags: \(combinedTags)")
                                                .font(.footnote)
                                                .foregroundColor(.blue)
                                        }
                                    }
                                    Spacer()
                                }
                                .swipeActions {
                                    // Delete all events in this phase
                                    Button(role: .destructive) {
                                        deleteAll(phaseEvents)
                                    } label: {
                                        Image(systemName: "trash")
                                    }
                                }
                            }
                        } header: {
                            Text("\(phase.rawValue.capitalized) Phase")
                        }
                    }
                }
            }
            .navigationTitle("Events List")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button {
                        showTagForm.toggle()
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .imageScale(.medium)
                    }
                }
            }
            // Present the TagFormView as a sheet
            .sheet(isPresented: $showTagForm) {
                TagFormView()
            }
        }
    }

    private func deleteAll(_ events: [Event]) {
        for e in events {
            myEvents.delete(e)
        }
    }
}

struct EventsListView_Previews: PreviewProvider {
    static var previews: some View {
        EventsListView()
            .environmentObject(EventStore(preview: true))
    }
}



===== ListViewRow.swift =====

//
//  ListViewRow.swift
//  Rhythm
//
//  Created by user on 9/27/24.
//

import SwiftUI

struct ListViewRow: View {
    let event: Event
    @Binding var formType: EventFormType?

    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                HStack {
                    Text(event.eventType.icon)
                        .font(.system(size: 40))
                    Text("\(event.eventType.rawValue.capitalized) Phase")
                }
                Text(event.date.formatted(date: .abbreviated, time: .shortened))
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                if !event.tags.isEmpty {
                    Text("Tags: \(event.tags)")
                        .font(.footnote)
                        .foregroundColor(.blue)
                }
            }
            Spacer()
            Button("Edit") {
                formType = .update(event)
            }
            .buttonStyle(.bordered)
        }
    }
}

struct ListViewRow_Previews: PreviewProvider {
    static let sampleEvent = Event(
        eventType: .menstrual,
        date: Date(),
        note: "Example note",
        tags: "cramping, chocolate"
    )
    static var previews: some View {
        ListViewRow(event: sampleEvent, formType: .constant(.update(sampleEvent)))
    }
}



===== StartTabView.swift =====
//
//  StartTabView.swift
//

import SwiftUI

struct StartTabView: View {
    // Controls which tab is selected
    @AppStorage("selectedTab") private var selection = 0

    var body: some View {
        TabView(selection: $selection) {
            EventsListView()
                .tabItem {
                    Label("List", systemImage: "list.bullet")
                }
                .tag(0)

            EventsCalendarView()
                .tabItem {
                    Label("Calendar", systemImage: "calendar")
                }
                .tag(1)

            SettingsCycleInfoView()
                .tabItem {
                    Label("Settings", systemImage: "gearshape.fill")
                }
                .tag(2)
        }
    }
}

struct StartTabView_Previews: PreviewProvider {
    static var previews: some View {
        StartTabView()
            .environmentObject(EventStore(preview: true))
    }
}



===== OnboardingView.swift =====
//  OnboardingView.swift
//

import SwiftUI

struct OnboardingView: View {
    @EnvironmentObject var myEvents: EventStore
    @AppStorage("didFinishOnboarding") var didFinishOnboarding = false
    @AppStorage("selectedTab") var selectedTab = 0

    // Toggling this to true will push GettingStartedView onto this NavStack
    @State private var navigateToGetStarted = false

    var body: some View {
        NavigationStack {
            VStack(spacing: 24) {
                Text("Welcome to Rhythm!")
                    .font(.largeTitle)
                    .bold()
                    .padding(.top, 40)

                Text("Generate cycle events, track tags, and learn about phases.")
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                // High energy note about data privacy
                Text("Your privacy rocks – we NEVER collect your data! Let's keep your rhythm free and safe!")
                    .font(.subheadline)
                    .foregroundColor(.black)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)

                Image(systemName: "circlebadge.2.fill")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 80)
                    .padding(.bottom, 24)

                // "Continue" goes to GettingStartedView (back button is not hidden)
                Button("Continue") {
                    navigateToGetStarted = true
                }
                .buttonStyle(.borderedProminent)
                .padding(.bottom, 40)
            }
            .padding()
    
            // A "Skip" or "Done" approach in the top-right, if user doesn't want to see steps
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Skip") {
                        // Let user skip everything, set onboarding done,
                        // and jump them to the Settings tab if you like
                        selectedTab = 2
                        didFinishOnboarding = true
                    }
                }
            }
            // Push to GettingStartedView
            .navigationDestination(isPresented: $navigateToGetStarted) {
                GettingStartedView()
            }
        }
    }
}

struct OnboardingView_Previews: PreviewProvider {
    static var previews: some View {
        OnboardingView()
            .environmentObject(EventStore())
    }
}



===== PhasesFactsView.swift =====
//
//  PhasesFactsView.swift
//  Rhythm
//
//  Created by user on 1/3/25.
//

import SwiftUI

/// A simple container for the entire text of one phase block.
struct PhaseTextBlock: Identifiable {
    let id = UUID()
    let content: String
}

struct PhasesFactsView: View {
    
    /// All 4 phases, stored as complete multiline text blocks.
    /// Each block here is exactly what you wrote, including headings and spacing.
    private let phases: [PhaseTextBlock] = [
        PhaseTextBlock(content: """
1. Menstrual Phase

Approximate Timing: Day 1 to Day 5
(Overlaps with the early part of the follicular phase)

What’s Happening Biologically
Hormones: Levels of estrogen and progesterone are relatively low at the start of menstruation because the corpus luteum (leftover from the previous cycle) is no longer producing high levels of progesterone.
Uterine Lining: The endometrium (uterine lining) sheds, leading to menstrual bleeding.

Pregnancy Probability
Very Low: Since menstruation generally marks the beginning of a new cycle and ovulation is still roughly 10–14 days away, the probability of becoming pregnant is minimal during this time. However, it is not absolutely zero—especially if someone has a shorter cycle or if sperm remains viable in the reproductive tract for several days.

Common Mood & Symptoms
Mood: Some individuals may experience relief from premenstrual syndrome (PMS) symptoms once bleeding begins, while others might still feel mood fluctuations (cramps, fatigue, irritability).
Physical Symptoms: Cramping (dysmenorrhea), bloating, backaches, breast tenderness, and headaches. Energy levels may be lower.

Tips/Benefits:
Warm compresses or gentle heat can help relieve cramps.
Staying hydrated and keeping up light, moderate exercise (such as yoga, walking) can improve mood and circulation.
Iron-rich foods or supplements may help if you’re prone to low iron due to menstrual blood loss (consult with a healthcare provider for personalized advice).
"""),
        PhaseTextBlock(content: """
2. Follicular Phase

Approximate Timing: Day 1 to Day 13
(Begins on Day 1, overlaps with menstruation until bleeding stops; continues up to ovulation)

What’s Happening Biologically
Hormones: Follicle-stimulating hormone (FSH) from the pituitary gland stimulates ovarian follicles to develop. Estrogen levels begin to rise.
Ovarian Follicles: Several follicles start to mature, but usually only one becomes dominant and is prepared for ovulation.
Uterine Lining: The endometrium starts to thicken again under rising estrogen levels.

Pregnancy Probability
Increasing but Still Moderate: The closer you get to ovulation (toward the end of the follicular phase), the higher the chance of pregnancy if unprotected intercourse occurs. Sperm can survive up to about five days in fertile cervical mucus.

Common Mood & Symptoms
Mood: As estrogen climbs, many people notice improved mood, higher energy, clearer thinking, and an overall sense of well-being.
Physical Symptoms: A possible gradual boost in libido, more cervical fluid that is thinner and more elastic (“fertile mucus”), and potentially fewer PMS-like symptoms compared to the luteal phase.

Tips/Benefits:
This is often a good time for high-energy workouts and social activities.
If trying to conceive, tracking cervical mucus changes or using ovulation predictor kits can be helpful toward the end of the follicular phase.
"""),
        PhaseTextBlock(content: """
3. Ovulatory Phase

Approximate Timing: Around Day 14 (in a 28-day cycle)

What’s Happening Biologically
Hormones: A surge in luteinizing hormone (LH) triggers the dominant follicle in the ovary to release the mature egg (ovum).
Ovulation: The egg is released into the fallopian tube, where it remains viable for about 12–24 hours.

Pregnancy Probability
Peak Fertility Window: This is the highest probability time for conception. Sperm present in the reproductive tract around ovulation (up to five days prior, day of, or shortly after) can fertilize the egg.

Common Mood & Symptoms
Mood: Often an uptick in libido, energy, and confidence due to peaking estrogen and testosterone levels.
Physical Symptoms: Some individuals experience mild pelvic twinges (Mittelschmerz), increased cervical mucus (clear, stretchy, “egg white” consistency), possibly a slight increase in basal body temperature after ovulation.

Tips/Benefits:
If trying to conceive, having intercourse in the days leading up to and including ovulation is key.
Staying hydrated and listening to your body can help manage any mild ovulatory discomfort.
"""),
        PhaseTextBlock(content: """
4. Luteal Phase

Approximate Timing: Day 15 to Day 28

What’s Happening Biologically
Hormones: After the egg is released, the follicle transforms into the corpus luteum, which secretes progesterone (and some estrogen). Progesterone prepares the uterus for a possible pregnancy.
Uterine Lining: The endometrium becomes more glandular and thicker to potentially support an embryo.

Pregnancy Probability
Higher Early in the Luteal Phase, Then Decreases:
If fertilization and implantation occur, progesterone remains high (supported by human chorionic gonadotropin, or hCG) to sustain pregnancy.
If no implantation occurs, progesterone production drops, leading to the shedding of the uterine lining (menstruation).

Common Mood & Symptoms
Mood: Potential for PMS/PMDD symptoms due to falling progesterone and estrogen toward the end of the luteal phase if pregnancy does not occur. Symptoms may include irritability, low mood, anxiety, mood swings.
Physical Symptoms: Bloating, breast tenderness, fatigue, food cravings, changes in bowel habits, possible fluid retention.

Tips/Benefits:
Focus on nutrient-dense foods, balanced meals, and adequate hydration to stabilize mood and energy.
Moderate exercise, mindfulness, and stress-reduction techniques can alleviate PMS symptoms.
Tracking symptoms can help identify patterns and better manage the physical and emotional fluctuations.
""")
    ]
    
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // For each block of text, we parse it by lines
                    ForEach(phases) { block in
                        VStack(alignment: .leading, spacing: 6) {
                            let lines = block.content.components(separatedBy: .newlines)
                            
                            ForEach(lines.indices, id: \.self) { i in
                                let line = lines[i]
                                if line.isEmpty {
                                    // Empty line => add a small spacer for extra vertical space
                                    Spacer().frame(height: 8)
                                } else {
                                    // Show text, bolding anything before the first colon
                                    boldTextBeforeColon(line)
                                }
                            }
                        }
                        .padding()
                        .background(Color(uiColor: .secondarySystemBackground))
                        .cornerRadius(8)
                    }
                    
                    // Fun, lighthearted disclaimer at the bottom
                    Spacer().frame(height: 24)
                    Text("""
Disclaimer: The information above is for your general knowledge and educational purposes – not a substitute for professional medical advice! Always consult a doctor if you have any health concerns. Keep grooving, stay informed, and remember: your body is unique, and we're just here to help you find your rhythm.
""")
                        .font(.footnote)
                        .multilineTextAlignment(.center)
                        .foregroundColor(.secondary)
                        .padding(.horizontal)
                }
                .padding()
            }
            .navigationTitle("Menstrual Phases")
        }
    }
    
    /// A helper that returns a Text view with everything before the first colon (if any) in bold.
    @ViewBuilder
    private func boldTextBeforeColon(_ line: String) -> some View {
        if let colonIndex = line.firstIndex(of: ":") {
            let keyPart = line[..<colonIndex]    // e.g. "Hormones"
            let valPart = line[line.index(after: colonIndex)...] // e.g. " Levels of..."
            
            // Construct a single Text with the first portion in bold
            Text(.init("**\(keyPart):**\(valPart)"))
                .font(.body)
        } else {
            // No colon => just show normally
            Text(line)
                .font(.body)
        }
    }
}

struct PhasesFactsView_Previews: PreviewProvider {
    static var previews: some View {
        PhasesFactsView()
    }
}



===== SettingsCycleInfoView.swift =====
//
//  SettingsCycleInfoView.swift
//

import SwiftUI

struct SettingsCycleInfoView: View {
    @EnvironmentObject var eventStore: EventStore

    @State private var selectedStartDate: Date = Date()
    @State private var selectedCycleLength: Int = 28
    @State private var showCycleGeneratedAlert = false
    @State private var showArchivedAlert = false

    // MARK: - Archived Data
    @State private var groupedArchivedData: [ArchivedDataBlock] = []
    private let archivedDataKey = "com.example.rhythm.archivedData"

    // MARK: - Lifecycle
    init() {
        loadArchivedData()
    }

    var body: some View {
        NavigationStack {
            Form {
                // -- "Getting Started" Section
                Section(header: Text("Getting Started")) {
                    NavigationLink("Let’s Get Started") {
                        GettingStartedView()
                    }
                }

                // Menstrual Phases Info Section
                Section(header: Text("Menstrual Phases Info")) {
                    NavigationLink("Learn more about phases") {
                        PhasesFactsView()
                    }
                }

                // Cycle Information Section
                Section(header: Text("Cycle Information")) {
                    DatePicker(
                        "First Day of Current Cycle",
                        selection: $selectedStartDate,
                        displayedComponents: .date
                    )
                    Stepper(value: $selectedCycleLength, in: 20...40) {
                        Text("Cycle Length: \(selectedCycleLength) days")
                    }
                }

                // Generate Cycle Events Section
                Section(
                    header: Text("Generate Events"),
                    footer: Text("This clears existing events and regenerates new dates for the upcoming cycle.")
                ) {
                    Button {
                        DispatchQueue.main.async {
                            eventStore.generateCycleEvents(
                                startDate: selectedStartDate,
                                cycleLength: selectedCycleLength
                            )
                            showCycleGeneratedAlert = true
                        }
                    } label: {
                        Text("Generate Cycle Events")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.borderedProminent)
                }

                // Archive Section
                Section(
                    header: Text("Archive Data"),
                    footer: Text("Archiving will save the existing events. New events will need to be regenerated.")
                ) {
                    Button {
                        archiveCurrentData()
                    } label: {
                        Text("Archive Current Data")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.borderedProminent)

                    NavigationLink("View Archived Data") {
                        // Pass a binding + a closure to clear the archive
                        ArchivedDataView(
                            groupedArchivedData: $groupedArchivedData
                        ) {
                            // Clear all blocks from memory + from disk
                            groupedArchivedData.removeAll()
                            saveArchivedData()
                        }
                    }
                }
            }
            .navigationTitle("Settings")
            .alert("Cycle Events Generated", isPresented: $showCycleGeneratedAlert) {
                Button("OK", role: .cancel) {}
            }
            .alert("Data Archived Successfully", isPresented: $showArchivedAlert) {
                Button("OK", role: .cancel) {}
            }
        }
    }

    // MARK: - Archiving
    private func archiveCurrentData() {
        let currentEvents = eventStore.events
        guard !currentEvents.isEmpty else { return }

        // Group events by phase
        let grouped = Dictionary(grouping: currentEvents) { $0.eventType }
            .sorted { $0.key.rawValue < $1.key.rawValue }
            .map { (key, events) in
                ArchivedDataBlock.PhaseEvents(eventType: key, events: events)
            }

        // Build a new ArchivedDataBlock (auto-generates id)
        let newBlock = ArchivedDataBlock(
            date: Date(),
            groupedEvents: grouped
        )

        // Append & sort newest at the top
        groupedArchivedData.append(newBlock)
        groupedArchivedData.sort { $0.date > $1.date }

        // Clear current events (optional)
        eventStore.events.removeAll()

        // Persist archived data
        saveArchivedData()

        // Show success alert
        showArchivedAlert = true
    }

    private func loadArchivedData() {
        guard let data = UserDefaults.standard.data(forKey: archivedDataKey) else { return }
        do {
            let decoded = try JSONDecoder().decode([ArchivedDataBlock].self, from: data)
            groupedArchivedData = decoded
        } catch {
            print("Error decoding archived data: \(error)")
        }
    }

    private func saveArchivedData() {
        do {
            let data = try JSONEncoder().encode(groupedArchivedData)
            UserDefaults.standard.set(data, forKey: archivedDataKey)
        } catch {
            print("Error encoding archived data: \(error)")
        }
    }
}



===== TagFormView.swift =====
//
//  TagFormView.swift
//

import SwiftUI

enum TagCategory: String, CaseIterable {
    case dietary = "Dietary"
    case exercise = "Exercise"
    case medication = "Medication"
    case mood = "Mood"
    case symptom = "Symptom"
    case other = "Other"
}

struct TagFormView: View {
    @EnvironmentObject var myEvents: EventStore
    @Environment(\.dismiss) var dismiss

    @State private var category: TagCategory = .dietary
    @State private var customType: String = ""
    @State private var tagDate = Date()
    
    /// No toggle anymore; we always do "all day"
    private let isAllDay = true

    var body: some View {
        NavigationStack {
            Form {
                Picker("Category", selection: $category) {
                    ForEach(TagCategory.allCases, id: \.self) { cat in
                        Text(cat.rawValue).tag(cat)
                    }
                }

                TextField("Specific Type (e.g. chocolate)", text: $customType)

                // DatePicker for date only
                DatePicker("Date", selection: $tagDate, displayedComponents: .date)
            }
            .navigationTitle("Add a New Tag")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save") {
                        saveTag()
                        dismiss()
                    }
                }
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }

    private func saveTag() {
        // e.g. "Dietary:Chocolate" if customType == "chocolate"
        let newTag = "\(category.rawValue):\(customType.isEmpty ? "unspecified" : customType)"

        // We'll always compare ignoring the time
        let targetStartOfDay = tagDate.startOfDay

        for event in myEvents.events {
            let eventStartOfDay = event.date.startOfDay

            // If the event is on the same day, attach the tag
            if eventStartOfDay == targetStartOfDay {
                var updated = event
                if updated.tags.isEmpty {
                    updated.tags = newTag
                } else {
                    updated.tags += ", \(newTag)"
                }
                myEvents.update(updated)
            }
        }
    }
}



